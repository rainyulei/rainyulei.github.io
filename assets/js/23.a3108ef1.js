(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{295:function(n,e,a){"use strict";a.r(e);var t=a(0),r=Object(t.a)({},function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"webpack-环境配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-环境配置","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack 环境配置")]),n._v(" "),a("h3",{attrs:{id:"使用环境变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用环境变量","aria-hidden":"true"}},[n._v("#")]),n._v(" 使用环境变量")]),n._v(" "),a("p",[n._v("在开发环境 使用 dev 上线环境使用 production 测试环境使用 test，可以使用 webpack 自带插件 webpack.DeffinePlugin")]),n._v(" "),a("pre",[a("code",[n._v("```javascript\nplugins: [new webpack.DefinePlugin(\n    # 第一种 方法\n    DEV:\"'dev'\"//要用双引号  内部嵌套一个单引号，因为如果只写一个引号相当于 console。log（dev）这个时候dev 是未定义的\n    # 第二种方法\n    DEV:JSON.stringify('production'),//输出字符串\n    FLAG:'true',//输出boolean  的true\n    EXPORESSION:'1+1' //输出2//在内部可以直接使用这些值\n)]\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"区分环境变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区分环境变量","aria-hidden":"true"}},[n._v("#")]),n._v(" 区分环境变量")]),n._v(" "),a("p",[n._v("创建三个配置文件，webpack.base.js webpack.production.js webpack.development.js")]),n._v(" "),a("pre",[a("code",[n._v("使用 webpack-merge\n\n    ```javascript\n    # 安装\n    npm i webpack-merge -D\n    # 在开发环境中使用\n    let {smart}  = require('webpack-merge')\n    let base = require('./webpack.base.js')\n    module.export=smart(base,{//集成了base中的所有配置 并且把mode 环境配置更改为development\n        mode:'development',\n        devserver,\n        devtool...\n    })\n    # 在生产环境中使用\n     let {smart}  = require('webpack-merge')\n    let base = require('./webpack.base.js')\n    module.export=smart(base,{//集成了base中的所有配置 并且把mode 环境配置更改为development\n        mode:'production',\n        minimizer...\n    })\n    ```\n")])]),n._v(" "),a("h2",{attrs:{id:"webpack-的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的优化","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack 的优化")]),n._v(" "),a("h3",{attrs:{id:"webpack-的忽略解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的忽略解析","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack 的忽略解析")]),n._v(" "),a("p",[n._v("配置不去解析特定包，看到包就忽略掉 在 module 选项下 配置"),a("code",[n._v("noParse:/jquery/")]),n._v(",这样可以根据通配符")]),n._v(" "),a("pre",[a("code",[n._v("找到 jquery 而不去解析 jquery 中的依赖项\n")])]),n._v(" "),a("h3",{attrs:{id:"配置-js-时默认会默认解析-node-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置-js-时默认会默认解析-node-modules","aria-hidden":"true"}},[n._v("#")]),n._v(" 配置 js 时默认会默认解析 node-modules")]),n._v(" "),a("p",[n._v("这个时候需要配置 babel 的排除和包含关系，排除 exclude 包含 include")]),n._v(" "),a("pre",[a("code",[n._v("```javascript\n{\n    test:/\\.js/,\n    exclude:/node_modules/,//排除node-modules 目录\n    include:path.resolve('src'),//包含 src目录，意思时只在src 中进行寻找\n    use:{\n        loader:'babel-loader',\n        options:{\n            presets:[\n                '@babel/preset-env',\n                '@babel/preset-react'\n            ]\n        }\n    }\n}\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"关于某些库的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于某些库的优化","aria-hidden":"true"}},[n._v("#")]),n._v(" 关于某些库的优化")]),n._v(" "),a("p",[n._v("忽略掉第三方库内引用了却在实际开发中没有使用的代码块，使用 webpack.IgnorPlugin()")]),n._v(" "),a("pre",[a("code",[n._v("```javascript\n# 使用\nplugins：[\n    new webpack.IgnorePlugin(/\\./locale/,/monent/)//如果在moment中引用了。locale 这个文件夹 就忽略掉这个打包请求\n]\n# 自己手动引用忽略的包 这样就可以减小打包体积\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"动态链接库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态链接库","aria-hidden":"true"}},[n._v("#")]),n._v(" 动态链接库")]),n._v(" "),a("p",[n._v("如果在开发过程中需要某些第三方的库，这些库在后期过程中时根本不会产生变动并且这些库又很大，所以这分割时候")]),n._v(" "),a("pre",[a("code",[n._v("可以在打包的过程中先抽离打包出这个库，然后把这些库作为后续开发的依赖引入。\n\n```javascript\n# 新建配置文件webpack.config.react.js,这个配置文件作为打包第三方库依赖的配置文件\nlet path = require('path')\nconst webpack =require('webpack')\nmodule.export={\n    mdoe:'development',\n    extry:{\n        react:['react','react-dom']\n    }\n    output:{\n        filename:'_dll_[name].js',//打包生成第三方库的文件名称\n        path:path.resolve(__dirname,'dist'),//生成路径\n        library:'_dll_[name]',//生成第三方模块的入口变量名称\n        libaryTarget:'var'//caonst commenjs ... 生成第三方库的导出方式  一般是使用var 默认不写是var\n\n    },\n    plugins:[\n        new webpack.DLLPlugin({\n            name:'_dll_[name]',//这个名字和libary  名字要相同，打包出依赖的第三方库\n            path:path.resolve(__dirname,'dist','manifest.json')//生成第三方库 在我们些的js 中引用和依赖的地图\n        })\n    ]\n}\n//根据上面文件打包会出现一个 manifest.json 关系对应地图 和一个_dll_react.js的文件\n//使用上面的文件  在html  中引入 ./_dll_react.js\n//然后再wenpack。config。js  中指定如果在打包过程中华又依赖关系到react  或者react-dom  那么去动态链接库中查找  而不是重新对node-modules  打包\n//\nplugins：{\n    new webpack.DLLReferencePlugin({\n        manifest:path.resolve(__dirname,'dist','minifest.json') //引用重新打包的依赖地图\n    })\n}\n\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"多线程打包实现快速打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程打包实现快速打包","aria-hidden":"true"}},[n._v("#")]),n._v(" 多线程打包实现快速打包")]),n._v(" "),a("p",[n._v("当项目比较大的时候使用多线程打包会加快速度 ，")]),n._v(" "),a("pre",[a("code",[n._v("使用 happypack\n\n```javascript\n//安装\nnpm i happypack -D\n//使用\nconst HappyPackPlugin = reuqire('happypack')\n//在module中需要使用多线程快速打包的地方\nmodule:{\n    noParse:/jquery/，\n    rules:[\n        {\n            test:/\\.js$/,\n            exclude:/node_modules/,\n            use:'HappyPackPlugin/loader?id=js'\n        }，\n        {\n            test:/\\.css$/,\n            use:'HappyPackPlugin/loader?id=css'\n        }\n    ]\n},\n//在plugins  中指定happypack\n\nplugins:[\n    new HappyPackPlugin({//通过id=js 找到上面的use  然后是u用happy 中定义的规则解析器进行打包\n        id:'js',\n        use:[\n            {\n                loader:'babel-loader',\n                options:{\n                    presets:[\n                        '@babel/preset-env',\n                        '@babel/preset-react'\n                    ]\n                }\n            }\n        ]\n    }),\n    new HappyPackPlugin({//通过id=css 找到上面的use  然后是u用happy 中定义的规则解析器进行打包\n        id:'css',\n        use:[\n            {\n                loader:MinicssWebpackPlugin.loader,\n                options:{\n                }\n            },\n            'css-loader',\n            'postcss-loader'\n        ]\n    })\n]\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"webpack-中的自带优化打包，"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-中的自带优化打包，","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack 中的自带优化打包，")]),n._v(" "),a("pre",[a("code",[n._v("- webpack 在打包的时候默认在生产环境下会去除掉 import 却没有使用的代码块，而在开发环境下不会，这种叫做 tree-shaking\n  把没用到的代码自动删除掉，而如果使用 require 打包的时候会把没用到的代码也打包，也就是 require 不支持 tree-shaking\n- scope hosting 在 webpack 中会自动省略一些可以简化的代码\n")])]),n._v(" "),a("h3",{attrs:{id:"抽取公用代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽取公用代码","aria-hidden":"true"}},[n._v("#")]),n._v(" 抽取公用代码")]),n._v(" "),a("p",[n._v("多用于多入口，与动态链接库有很大的差别，动态链接库最好不要使用与线上环境和整体性比较差的库。")]),n._v(" "),a("pre",[a("code",[n._v("```javascript\n// 在多入口多界面的时候如果 A 界面和B 界面又公用的部分  我们希望把他们单独抽取出来这样在A页面加载的时候加载出来 在B页面就不要再进行加载了\n//首先配置多入口\nmodule.exports = {\n  mode: 'production',\n  entry: {\n    index: __dirname + '/src/index.js',\n    other: __dirname + '/src/other.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  optimization: {\n    splitChunks: {\n      //分割代码块\n      cacheGroups: {//缓存组\n        common: {//配置公共代码块的规则\n            chunks:'initial',//从入口处就开始提取代码  后面还有异步模块\n            miniSize:0，//超过大小就会被抽离\n            miniChunks：2，//引用多少次会被抽离  至少引用2次就会被抽离\n\n        },\n        verder:{//第三方模块被重复引用也会被抽离单个打包\n            priority:1,//优先抽离的权重，配置为1 权重越高先抽离  抽离 好单独的第三方然后再抽离 公用自定义代码 生成单独文件\n            test:/node_modules/,//正则匹配，可以使用es  正则匹配返回值形式\n            chunks:'initial',//从入口处就开始提取代码  后面还有异步模块，all async\n            miniSize:0，//超过大小就会被抽离\n            miniChunks：2，//引用多少次会被抽离  至少引用2次就会被抽离，默认为1次  2次是抽离公用代码的最小颗粒度\n        }\n      }\n    }\n  }\n}\n```\n")])]),n._v(" "),a("h3",{attrs:{id:"懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#懒加载","aria-hidden":"true"}},[n._v("#")]),n._v(" 懒加载")]),n._v(" "),a("pre",[a("code",[n._v("```javascript\nlet btn = document.createElement('button')\nbtn.innerHTML = 'click'\nbtn.addEventListener('click', function() {\n  import('./source.js').then(data => {\n    data.dafault\n  })\n})\ndocument.body.appendChild(btn)\n```\n\n如果要实现上面的懒加载功能--点击按钮异步加载一个 js 代码块 然后自己执行\n实现上面功能需要 babel 的语法自动导入的插件 @babel/plugin-syntax-dynamic-import 需要再 wabpack 中设置\n\n```javascript\n//安装\nnpm i  @babel/plugin-syntax-dynamic-import -D\n//使用\n{\n    test：/.js$,\n    use:[\n        {\n            loader:'babel-loader',\n            options:{\n                presets:[\n                    '@babel/preset-env',\n                    '@babel/preset-react'\n                ],\n                plugins:[\n                    '@babel/plugin-syntax-dynamic-import' //实现动态加载 ，在 引入的地方在defalt  上拿出来使用\n                ]\n            }\n        }\n    ]\n}\n// vue  react  等的路由的懒加载都是通过这种方法来实现的 实质上是jsonp\n```\n")])]),n._v(" "),a("p",[n._v("在实际生产中打包会生成两个 js 文件一个是正常页面使用的 index。js 还会生成一个 懒加载请求的 1.js 当执行懒加载的时候才会请求到 1.js")]),n._v(" "),a("h3",{attrs:{id:"热更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热更新","aria-hidden":"true"}},[n._v("#")]),n._v(" 热更新")]),n._v(" "),a("p",[n._v("在开发过程中，每次保存或者代码有改变的时候会重新更新 代码重启服务器")]),n._v(" "),a("pre",[a("code",[n._v("注意：这个插件和 cleanwebpackplugin 插件同时使用会出现问题\n\n```javascript\n\ndevServer:{\n    port:3000,\n    hot:true,//开启热更新\n    open:true，\n    contentBase:'./dist'\n\n},\nplugins:[\n    new webpack.NameModulePlugin(),//告诉我们热更新的模块的名称，打印更新的模块路径\n    new webpack.HotModlePrplacementPlugin()//wenpack 热更熊模块支持\n]\n//使用  热更新模块引入后会自动起作用  而NameModulePlugin 则要配合使用\n\n//在js中可以写\nimport str from './index.js'\nconsole.log(str)\nif(module.hot){\n    module.hot.accept('./index',()=>{//这个就是namemodule的作用\n        console.log('文件更新了')\n        let str = require('./index.js')\n        console.log(str)\n    })\n}\n```\n")])])])},[],!1,null,null,null);e.default=r.exports}}]);
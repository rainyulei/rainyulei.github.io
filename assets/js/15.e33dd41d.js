(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{304:function(e,n,a){"use strict";a.r(n);var t=a(0),r=Object(t.a)({},function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"electron"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#electron","aria-hidden":"true"}},[e._v("#")]),e._v(" Electron")]),e._v(" "),a("ol",[a("li",[e._v("安装")]),e._v(" "),a("li",[e._v("目录结构")]),e._v(" "),a("li",[e._v("解析代码")])]),e._v(" "),a("h2",{attrs:{id:"初步使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初步使用","aria-hidden":"true"}},[e._v("#")]),e._v(" 初步使用")]),e._v(" "),a("h3",{attrs:{id:"electron-的进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#electron-的进程","aria-hidden":"true"}},[e._v("#")]),e._v(" electron 的进程")]),e._v(" "),a("p",[e._v("在 electron 中 被 electron 直接运行的脚本 package 指定的 main 脚本为主进程,而所有的 web 界面运行在一个独立的进程中,属于渲染进程,我们可以通过主进程创建一个渲染进程,但是当一个 web 界面被销毁的时候对应的渲染进程也会被终止.")]),e._v(" "),a("h3",{attrs:{id:"node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node","aria-hidden":"true"}},[e._v("#")]),e._v(" node")]),e._v(" "),a("p",[e._v("在 electron 中可以使用所有的 nodejs 的的接口")]),e._v(" "),a("h3",{attrs:{id:"app-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#app-对象","aria-hidden":"true"}},[e._v("#")]),e._v(" app 对象")]),e._v(" "),a("p",[e._v("这个对象提供了一系列对象事件来控制整个应用程序的生命周期,从打开到关闭.同时也有提供一些方法管理应用程序的状态和行为.")]),e._v(" "),a("h3",{attrs:{id:"browserwindow-窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#browserwindow-窗口","aria-hidden":"true"}},[e._v("#")]),e._v(" BrowserWindow 窗口")]),e._v(" "),a("p",[e._v("创建和控制浏览器窗口,实现显示界面,每一个 BrowserWindow 对象都是一个渲染进程,同时该对象也提供了各种操控的 api 包括事件属性和方法")]),e._v(" "),a("h3",{attrs:{id:"bw1-webcontents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bw1-webcontents","aria-hidden":"true"}},[e._v("#")]),e._v(" bw1.webContents")]),e._v(" "),a("p",[e._v("类似于浏览器中的 window,这个对象下由个方法 opendevtools 开启调试,与窗口有关的内容都是通过这个来操纵的.")]),e._v(" "),a("h3",{attrs:{id:"loadfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadfile","aria-hidden":"true"}},[e._v("#")]),e._v(" loadFile()")]),e._v(" "),a("p",[e._v("加载页面(也就是我们的要显示的内同),页面的地址使用相对路径,相对路径相对于应用程序的根目录,记载本地的协议")]),e._v(" "),a("h3",{attrs:{id:"loadurl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadurl","aria-hidden":"true"}},[e._v("#")]),e._v(" loadurl")]),e._v(" "),a("p",[e._v("使用 URL 协议加载文件可以时 HTTP 协议 也可以时 file 协议 ,加载远程协议")]),e._v(" "),a("h3",{attrs:{id:"窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#窗口","aria-hidden":"true"}},[e._v("#")]),e._v(" 窗口")]),e._v(" "),a("p",[e._v("一般窗口 无边框窗口 透明窗口")]),e._v(" "),a("p",[e._v("无边框窗口 frame:false 主要用来实现所有的按钮自定义\n无边框的窗口先要达到点击拖动效果 可以使用 css 中的 -webkit-app-region:drag 这个属性\n透明窗口 frame:false transparent:true")]),e._v(" "),a("h3",{attrs:{id:"父子窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子窗口","aria-hidden":"true"}},[e._v("#")]),e._v(" 父子窗口")]),e._v(" "),a("p",[e._v("在子窗口的 options 内部增加 parent 选项 value 指向父窗口,子窗口挂载在父窗口上 永远在父窗口前面,会同时被关闭.")]),e._v(" "),a("h3",{attrs:{id:"模态窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模态窗口","aria-hidden":"true"}},[e._v("#")]),e._v(" 模态窗口")]),e._v(" "),a("p",[e._v("parent:父窗口, model:true 子窗口此使会禁用父窗口 类似于 alert")]),e._v(" "),a("h3",{attrs:{id:"菜单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#菜单","aria-hidden":"true"}},[e._v("#")]),e._v(" 菜单")]),e._v(" "),a("p",[e._v("有 normal submenu separator 以及 checkbox 和 redio 五种菜单类型")]),e._v(" "),a("pre",[a("code",[e._v("```javascript\nlet m1 = new Menu() //创建菜单\nlet mi1 = new MenuItem({\n  type: 'normal',\n  label: '文件'\n}) //内部为options\nlet mi2 = new MenuItem({\n  type: 'submenu',\n  label: '查看',\n  submenu: [\n    {\n      type: 'normal',\n      label: '查看文件'\n    },\n    {\n      type: 'separator' //菜单的分隔符\n    },\n    {\n      type: 'normal',\n      label: '查看文件夹'\n    },\n    {\n        type:'checkbox'\n        label:'选项1'\n        checked:true //这个选项等到选中状态\n    },\n      {\n        type:'radio'\n        label:'aaaaa'\n        checked:true //这个选项等到选中状态\n    },  {\n        type:'radio'\n        label:'bbbbb'\n\n    }\n  ]\n})\nm1.append(mi1)\nm1.append(mi2)\n//指定该菜单显示的主题 具体哪个窗口  右键  上下文位置\n/**\n * 菜单位置  1 顶层带单 2 上下文菜单\n */\n//这个时menu  下的顶层方法  把菜单添加到窗口的最顶层\nMenu.setApplicationMenu(m1)\n```\n\nicon 菜单前面的小图标 visiabled 是否可见 enabled 是否可用\n")])]),e._v(" "),a("h3",{attrs:{id:"角色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#角色","aria-hidden":"true"}},[e._v("#")]),e._v(" 角色")]),e._v(" "),a("p",[e._v("也就是系统已经预设好的菜单,然后我们使用把他们赋值到按键上")]),e._v(" "),a("pre",[a("code",[e._v("```javascript\nlet mi1 = new MenuItem({\n  role: 'quit',\n  label: '退出'\n})\n```\n")])]),e._v(" "),a("h3",{attrs:{id:"菜单事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#菜单事件","aria-hidden":"true"}},[e._v("#")]),e._v(" 菜单事件")]),e._v(" "),a("pre",[a("code",[e._v("```javascript\nlet mi1 = new MenuItem({\n  type: 'normal',\n  label: '退出',\n  click() {\n    app.quit()\n  }\n})\n```\n")])]),e._v(" "),a("h3",{attrs:{id:"数据共享与通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据共享与通信","aria-hidden":"true"}},[e._v("#")]),e._v(" 数据共享与通信")]),e._v(" "),a("p",[e._v("如果有两个窗口 或者渲染进程和主进程之间的通信")]),e._v(" "),a("pre",[a("code",[e._v("- 在渲染进程中不能直接获取到主进程中的数据的 ,在渲染进程中通过 electron 的 remote 在渲染进程中拿到主进程模块,该对象下有一个方法 getGlobal()\n\n  ```javascript\n  在 外部  进程把变量挂载到global  上\n  <script>\n    const {remote} = require('electron') ;//引入remote 模块 console.log(remote)//\n    console.log(remote.getGlobal('username'))\n  <\/script>\n  ```\n\n- 通过进程通信 IPC ipcrenderer ipcmain\n\n  ```javascript\n  ipcRenderer.send(channel[,arg1][,arg2]....)//只能在渲染进程中使用\n  ipcMain.on(channel,listener)\n  listener(e,data) //监听\n      e.sender.send()//回复\n  //具体的实现\n  // 1 在渲染进程\n   const {\n      remote,\n      ipcRenderer\n  } = require('electron')\n   const aaaBtn = document.getElementById('aaa')\n  aaaBtn.onclick = () => {\n      ipcRenderer.send('getdata', 'username')//发送请求信息\n  }\n  // 2 在主进程中\n\n    ipcMain.on('getdata', (e, data) => {//监听到 渲染进程的请求   e  事件对象   data  对面的请求数据\n      console.log(e)\n   console.log(data)\n  e.sender.send('sendData', datas[data]) //发送 相应数据  sendData 频道名称 第二个参数 数据\n   })\n   //3 在渲染进程中\n   ipcRenderer.on('sendData', (e, data) => { //获取到数据\n      console.log(data)\n  })\n\n  ```\n\n- 主进程主动发消息到渲染进程 通过 win.webContents.send('hello')\n\n  ```javascript\n  win.webContents.send('hello', 'hello world')\n  // 在渲染京城中 通过ipcRenderer.on()\n  ipcRenderer.on('hello', (e, data) => {\n    console.log(data)\n  })\n  ```\n\n- 多个窗口之间的数据传递,通过浏览器的 API storage 或者 indexedDB,多个窗口之间其实时同域下的.\n\n  ```javascript\n  localstorage.setItem('val', 'hahah')\n  // 在其他窗口之间\n  localstorage.getItem('val')\n  ```\n\n- 在渲染进程中 可以使用 remote.app.exit() 退出窗口\n- 在渲染京城中最小化 remote.getcurrentWindow()//这个方法返回当前的渲染进程的窗口 渲染进程窗口.minimize() 最小化\n")])]),e._v(" "),a("h3",{attrs:{id:"通知-notification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通知-notification","aria-hidden":"true"}},[e._v("#")]),e._v(" 通知 notification")]),e._v(" "),a("p",[e._v("在 win7 和 mac 系统上可以实现 右下角的通知信息功能")]),e._v(" "),a("h3",{attrs:{id:"election-打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#election-打包","aria-hidden":"true"}},[e._v("#")]),e._v(" election 打包")]),e._v(" "),a("p",[e._v("打包的框架 election-builder")]),e._v(" "),a("h3",{attrs:{id:"nsis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nsis","aria-hidden":"true"}},[e._v("#")]),e._v(" NSIS")]),e._v(" "),a("p",[e._v("帮助生成程序的安装打包向导")]),e._v(" "),a("pre",[a("code",[e._v('```javascript\n"win": {\n  "icon": "./logo.png",\n  "target": [\n    "nsis"\n  ]\n},\n"nsis": {\n  "oneclick": false, //一键生成安装\n  "allowToChangeInstallationDirectory": true, //允许安装更改目录\n  "installerIcon": "./logo.png", //安装的图标\n  "installerHeader": "",//安装的头\n  "license": "./source/license.text"//授权信息\n}\n```\n')])])])},[],!1,null,null,null);n.default=r.exports}}]);